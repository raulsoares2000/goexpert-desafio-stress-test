package cmd

import (
	"fmt"
	"github.comcom/spf13/cobra"
	"net/http"
	"os"
	"strings" // NOVO: Para processar as mensagens de erro
	"sync"
	"sync/atomic"
	"time"
)

// ... (o início do arquivo permanece o mesmo) ...
var chargeCmd = &cobra.Command{
	Use:   "charge",
	Short: "Realiza um stress test no url especificado",
	Long:  "Realiza um stress test no url especificado, usando um número x de requests e x de workers",
	Run: func(cmd *cobra.Command, args []string) {
		url, err := cmd.Flags().GetString("url")
		if err != nil {
			fmt.Println("Erro ao ler a flag 'url':", err)
			os.Exit(1)
		}
		requests, err := cmd.Flags().GetInt("requests")
		if err != nil {
			fmt.Println("Erro ao ler a flag 'requests':", err)
			os.Exit(1)
		}
		concurrency, err := cmd.Flags().GetInt("concurrency")
		if err != nil {
			fmt.Println("Erro ao ler a flag 'concurrency':", err)
			os.Exit(1)
		}
		loadTest(url, requests, concurrency)
	},
}

func init() {
	rootCmd.AddCommand(chargeCmd)
	chargeCmd.Flags().StringP("url", "u", "", "URL do serviço a ser testado")
	chargeCmd.Flags().IntP("requests", "r", 0, "Número total de requests")
	chargeCmd.Flags().IntP("concurrency", "c", 0, "Número de chamadas simultâneas")
	chargeCmd.MarkFlagRequired("url")
	chargeCmd.MarkFlagRequired("requests")
	chargeCmd.MarkFlagRequired("concurrency")
}

func loadTest(url string, requests, concurrency int) {
	var wg sync.WaitGroup
	var successCount atomic.Int64
	statusCodes := make(map[int]int)
	var statusCodesMutex sync.Mutex

	// Canais para comunicação
	requestTimes := make(chan time.Duration, requests)
	requestCounter := make(chan struct{}, requests)
	errorChan := make(chan error, requests) // NOVO: Canal para coletar os erros detalhados

	fmt.Println("Iniciando teste de carga...")
	startTime := time.Now()

	client := &http.Client{
		Timeout: 10 * time.Second, // Timeout mais curto para identificar timeouts mais rápido
	}

	for i := 0; i < concurrency; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for range requestCounter {
				start := time.Now()
				resp, err := client.Get(url)
				duration := time.Since(start)

				requestTimes <- duration

				if err == nil {
					if resp.StatusCode == http.StatusOK {
						successCount.Add(1)
					}
					statusCodesMutex.Lock()
					statusCodes[resp.StatusCode]++
					statusCodesMutex.Unlock()
					resp.Body.Close()
				} else {
					// ALTERADO: Em vez de apenas contar, enviamos o erro real para o canal
					errorChan <- err
				}
			}
		}()
	}

	for i := 0; i < requests; i++ {
		requestCounter <- struct{}{}
	}
	close(requestCounter)

	wg.Wait()
	close(requestTimes)
	close(errorChan) // NOVO: Fechamos o canal de erros após as goroutines terminarem

	totalDuration := time.Since(startTime)

	var totalResponseTime time.Duration
	requestCount := 0
	for rt := range requestTimes {
		totalResponseTime += rt
		requestCount++
	}

	// NOVO: Processamento dos erros detalhados
	errorCounts := make(map[string]int)
	for err := range errorChan {
		// Pegamos a mensagem de erro e a usamos como chave para o mapa
		// Usamos strings.Contains para agrupar erros semelhantes
		errMsg := err.Error()
		if strings.Contains(errMsg, "timeout") {
			errorCounts["timeout"]++
		} else if strings.Contains(errMsg, "connection refused") {
			errorCounts["connection refused"]++
		} else {
			errorCounts[errMsg]++
		}
	}

	var averageResponseTime time.Duration
	if requestCount > 0 {
		averageResponseTime = totalResponseTime / time.Duration(requestCount)
	}

	totalSuccess := successCount.Load()

	fmt.Println("\n--- Relatório do Teste de Carga ---")
	fmt.Printf("Tempo total de execução: %s\n", totalDuration)
	fmt.Printf("URL Alvo: %s\n", url)
	fmt.Printf("Total de requests planejados: %d\n", requests)
	fmt.Printf("Total de requests concluídos: %d\n", requestCount)
	fmt.Printf("Nível de concorrência: %d workers\n", concurrency)
	fmt.Printf("Tempo médio de resposta: %s\n", averageResponseTime)
	fmt.Println("------------------------------------")
	fmt.Printf("Requests com status HTTP 200 (Sucesso): %d\n", totalSuccess)

	// ALTERADO: Relatório de erros agora mostra os detalhes
	if len(errorCounts) > 0 {
		fmt.Println("Detalhes dos erros de conexão:")
		for errMsg, count := range errorCounts {
			fmt.Printf("  - %s: %d\n", errMsg, count)
		}
	}

	fmt.Println("Distribuição de outros códigos de status HTTP:")
	for code, count := range statusCodes {
		if code != http.StatusOK {
			fmt.Printf("  - HTTP %d: %d\n", code, count)
		}
	}
	fmt.Println("------------------------------------")
}